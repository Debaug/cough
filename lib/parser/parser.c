#include "parser/parser.h"

typedef struct Parser {
    String source;
    TokenStream tokens;
    usize pos;
    Reporter* reporter;
    ArrayBuf(Expression) expressions;
    ArrayBuf(usize) functions;
    AstStorage storage;
} Parser;

static bool parser_match(Parser* parser, TokenKind kind, Token* dst) {
    ArrayBuf(Token) tokens = parser->tokens.tokens;
    if (tokens.len == parser->pos) {
        return false;
    }
    if (tokens.data[parser->pos].kind != kind) {
        return false;
    }
    if (dst) {
        *dst = tokens.data[parser->pos];
    }
    parser->pos++;
    return true;
}

static void parser_skip_until(Parser* parser, TokenKind kind) {
    TokenStream tokens = parser->tokens;
    usize paren_depth = 0;
    while (parser->pos != tokens.tokens.len) {
        Token token = tokens.tokens.data[parser->pos];
        if (paren_depth == 0 && token.kind == kind) {
            return;
        }
        if (token.kind == TOKEN_PAREN_LEFT) {
            paren_depth++;
        }
        if (token.kind == TOKEN_PAREN_RIGHT && paren_depth >= 0) {
            paren_depth--;
        }
        parser->pos++;
    }
}

static ExpressionId box_expression(Parser* parser, Expression expression) {
    usize id = parser->expressions.len;
    array_buf_push(Expression)(&parser->expressions, expression);
    return id;
}

static Result parse_module(Parser* parser, Module* dst);
static Result parse_constant(Parser* parser, ConstantDef* dst);
// range may be NULL
static Result parse_expression(Parser* parser, ExpressionId* dst, Range* range);
// parser must not be exhausted
static Result parse_expression_head(Parser* parser, ExpressionId* dst, Range* dst_range);
// head token must be `fn`
static Result parse_function(Parser* parser, Function* dst, Range* range);
static Result parse_pattern(Parser* parser, Pattern* dst);
static Result parse_type_name(Parser* parser, TypeName* dst);
static Result parse_identifier(Parser* parser, Identifier* dst);

bool parse(
    TokenStream tokens,
    Reporter* reporter,
    Ast* dst
) {
    Parser parser = {
        .source = tokens.source,
        .tokens = tokens,
        .pos = 0,
        .reporter = reporter,
        .expressions = array_buf_new(Expression)(),
        .functions = array_buf_new(usize)(),
        .storage = ast_storage_new(),
    };
    Module module;
    parse_module(&parser, &module);
    ast_store(&parser.storage, parser.expressions.data);
    ast_store(&parser.storage, parser.functions.data);
    *dst = (Ast){
        .bindings = binding_registry_new(),
        .types = type_registry_new(),
        .expressions = parser.expressions,
        .functions = parser.functions,
        .root = module,
        .storage = parser.storage,
    };
    return reporter_error_count(reporter) == 0;
}

static Result parse_module(Parser* parser, Module* dst) {
    TokenStream tokens = parser->tokens;
    ArrayBuf(ConstantDef) global_constants = array_buf_new(ConstantDef)();
    while (parser->pos != tokens.tokens.len) {
        ConstantDef constant;
        if (parse_constant(parser, &constant) != SUCCESS) {
            parser_skip_until(parser, TOKEN_SEMICOLON);
            parser->pos++;
            continue;
        }
        array_buf_push(ConstantDef)(&global_constants, constant);
    }
    *dst = (Module){
        .global_constants = global_constants
    };
    return SUCCESS;
}

static Result parse_constant(Parser* parser, ConstantDef* dst) {
    Identifier name;
    if (parse_identifier(parser, &name) != SUCCESS) {
        return ERROR;
    }
    if (!parser_match(parser, TOKEN_COLON_COLON, NULL)) {
        return ERROR;
    }
    ExpressionId value;
    if (parse_expression(parser, &value, NULL) != SUCCESS) {
        return ERROR;
    }
    if (!parser_match(parser, TOKEN_SEMICOLON, NULL)) {
        return ERROR;
    }
    *dst = (ConstantDef){
        .name = name,
        .explicitly_typed = false,
        .type = TYPE_INVALID,
        .value = value,
        .binding = BINDING_ID_INVALID,
    };
    return SUCCESS;
}

static Result parse_expression(Parser* parser, ExpressionId* dst, Range* range_dst) {
    if (parser->pos == parser->tokens.tokens.len) {
        return ERROR;
    }

    ExpressionId expr;
    Range range;
    parse_expression_head(parser, &expr, &range);

    // parse function calls
    while (true) {
        if (parser->pos == parser->tokens.tokens.len) {
            break;
        }
        if (parser->tokens.tokens.data[parser->pos].kind != TOKEN_PAREN_LEFT) {
            break;
        }
        Range argument_range = range;
        ExpressionId argument;
        if (parse_expression(parser, &argument, &argument_range) != SUCCESS) {
            return ERROR;
        }
        range.end = argument_range.end;
        BinaryOperation function_call = {
            .operator = OPERATION_FUNCTION_CALL,
            .operand_left = expr,
            .operand_right = argument,
        };
        expr = box_expression(parser, (Expression){
            .kind = EXPRESSION_BINARY_OPERATION,
            .as.binary_operation = function_call,
            .range = range,
            .type = TYPE_INVALID,
        });
    }

    *dst = expr;
    if (range_dst) {
        *range_dst = range;
    }

    return SUCCESS;
}

static Result parse_expression_head(Parser* parser, ExpressionId* dst, Range* dst_range) {
    Token head = parser->tokens.tokens.data[parser->pos];
    Expression expr = { .type = TYPE_INVALID };

    switch (head.kind) {
    case TOKEN_PAREN_LEFT:;
        usize start = parser->pos++;
        parse_expression(parser, dst, NULL);
        if (!parser_match(parser, TOKEN_PAREN_RIGHT, NULL)) {
            return ERROR;
        }
        *dst_range = token_range_range(parser->tokens, (Range){ start, parser->pos });
        return SUCCESS;

    case TOKEN_FN:
        expr.kind = EXPRESSION_FUNCTION;
        if (
            parse_function(parser, &expr.as.function, &expr.range)
            != SUCCESS
        ) {
            return ERROR;
        }
        break;

    case TOKEN_FALSE:
        expr.kind = EXPRESSION_LITERAL_BOOL;
        expr.as.literal_bool = false;
        expr.range = token_range(parser->tokens, head);
        parser->pos++;
        break;
    case TOKEN_TRUE:
        expr.kind = EXPRESSION_LITERAL_BOOL;
        expr.as.literal_bool = true;
        expr.range = token_range(parser->tokens, head);
        parser->pos++;
        break;

    case TOKEN_IDENTIFIER:
        expr.kind = EXPRESSION_VARIABLE;
        Identifier name;
        // can't fail
        parse_identifier(parser, &name);
        expr.as.variable = (VariableRef){
            .name = name,
            .binding = BINDING_ID_INVALID,
        };
        expr.range = name.range;
        break;

    default:
        // FIXME: report error
        return ERROR;
    }

    ExpressionId id = parser->expressions.len;
    if (expr.kind == EXPRESSION_FUNCTION) {
        expr.as.function.function_id = parser->functions.len;
        array_buf_push(usize)(&parser->functions, id);
    }
    array_buf_push(Expression)(&parser->expressions, expr);

    *dst = id;
    *dst_range = expr.range;

    return SUCCESS;
}

static Result parse_function(Parser* parser, Function* dst, Range* range) {
    usize start = parser->pos++;
    Pattern input;
    if (parse_pattern(parser, &input) != SUCCESS) {
        return ERROR;
    }
    if (!parser_match(parser, TOKEN_ARROW, NULL)) {
        return ERROR;
    }
    TypeName output_type;
    if (parse_type_name(parser, &output_type) != SUCCESS) {
        return ERROR;
    }
    if (!parser_match(parser, TOKEN_DOUBLE_ARROW, NULL)) {
        return ERROR;
    }
    ExpressionId output;
    if (parse_expression(parser, &output, NULL) != SUCCESS) {
        return ERROR;
    }
    usize end = parser->pos;
    *dst = (Function){
        .input = input,
        .explicit_output_type = true,
        .output_type_name = output_type,
        .output_type = TYPE_INVALID,
        .output = output,
    };
    *range = token_range_range(parser->tokens, (Range){ start, end });
    return SUCCESS;
}

static Result parse_pattern(Parser* parser, Pattern* dst) {
    usize start = parser->pos;
    Identifier identifier;
    if (parse_identifier(parser, &identifier) != SUCCESS) {
        return ERROR;
    }
    if (!parser_match(parser, TOKEN_COLON, NULL)) {
        return ERROR;
    }
    TypeName type_name;
    if (parse_type_name(parser, &type_name) != SUCCESS) {
        return ERROR;
    }
    usize end = parser->pos;
    *dst = (Pattern){
        .kind = PATTERN_VARIABLE,
        .as.variable = {
            .name = identifier,
            .explicitly_typed = true,
            .type_name = type_name,
            .type = TYPE_INVALID,
            .binding = BINDING_ID_INVALID,
        },
        .explicitly_typed = true,
        .type_name = type_name,
        .type = TYPE_INVALID,
        .range = token_range_range(parser->tokens, (Range){ start, end }),
    };
    return SUCCESS;
}

static Result parse_type_name(Parser* parser, TypeName* dst) {
    Identifier identifier;
    if (parse_identifier(parser, &identifier) != SUCCESS) {
        return ERROR;
    }
    *dst = (TypeName){
        .kind = TYPE_NAME_IDENTIFIER,
        .as.identifier = identifier,
        .range = identifier.range,
    };
    return SUCCESS;
}

static Result parse_identifier(Parser* parser, Identifier* dst) {
    Token identifier;
    if (!parser_match(parser, TOKEN_IDENTIFIER, &identifier)) {
        return ERROR;
    }
    Range range = token_range(parser->tokens, identifier);
    *dst = (Identifier){
        .string = string_slice(parser->source, range),
        .range = range,
    };
    return SUCCESS;
}
